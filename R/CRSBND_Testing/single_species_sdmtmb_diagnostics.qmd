---
title: "Cross-Boundary Projections Diagnostics"
format: 
  html:
    self-contained: true
execute:
  echo: false
  message: false
  warning: false
---

# Model Evaluation for Cross Boundary

The following sections will cover how to pull out common diagnostics from single-species SDMTMB model outputs and some data visualization development for cross boundary metrics for US and Canadian population densities.


```{r}
# Load packages
library(raster)
library(units)
library(here)
library(tidyverse)
library(gmRi)
library(sf)
library(patchwork)
library(rcartocolor)
library(ggchicklet)
library(ggh4x)
library(ggside)
library(scales)
library(sdmTMB)



# Paths to Box Assets 
mills_path <- cs_path(box_group = "mills")
crsbnd_path <- str_c(mills_path, "Projects/Single_Species_SDMS/Results")

# Load the shapefiles
dfo_bounds  <- read_sf(here::here("local_data/Regions_for_CRSBND/DFO.shp"))
nmfs_bounds <- read_sf(here::here("local_data/Regions_for_CRSBND/NMFS.shp"))
land_sf     <- read_sf(here::here("COCA_SDM_app_dev/dev/scratch_data", "nw_atlantic_countries_crs32619.geojson"))
hague_sf <- read_sf(here::here("COCA_SDM_app_dev/dev/scratch_data", "hagueline_crs32619.geojson"))


# Need to get an area per region...number of cells per region
all_regs <- bind_rows(dfo_bounds, nmfs_bounds) |>
  mutate(area = st_area(geometry)) %>% 
  rename(jurisdiction = Region)
all_regs$regional_area <- set_units(all_regs$area, km^2)


# Get total area for later
#total_area <- st_area(st_union(all_regs))
total_area <- sum(all_regs$regional_area)


# Set factor levels for things throughout
mod_levels <- c(
  "Env",
  "Env + SeasFac",
  "Env + SeasonSVC",
  "Env + SP",
  "Env + SP + ST",
  "Env + SeasFac + SP + ST")
period_levels <- c("Baseline", "Mid-Century", "End-of Century", "drop")
season_levels <- c("Spring", "Summer", "Fall")


# # Set the theme
# theme_set(
#   theme_gmri(
#     legend.position = "bottom",
#     panel.grid.major.y = element_line(linewidth = 0.1),
#     axis.line.y = element_line(), 
#     axis.ticks.y = element_line()))

# Simple theme
theme_set(
  theme_minimal() +
  theme(
    text = element_text(family = "Avenir", size = 12),
    plot.title = element_text(face = "bold"),
    legend.position = "bottom",
    legend.title.position = "left",
    panel.grid.major.y = element_line(color = "#D3D3D330"),
    panel.grid.major.x = element_line(color = "#D3D3D330"),
    panel.grid.minor = element_blank(),
    axis.line = element_line(),
    axis.ticks = element_line(),
    legend.title = element_text(size = 12, face = "bold"),
    strip.text = element_text(family = "Avenir", face = "bold", size = 12),
    legend.box = "horizontal")
)

```


```{r}
#| label: map theme

# Plotting map theme
theme_map <- function(fontfam = "Avenir", guides = T, ...){
  list(
    # Theme options, with ellipse to add more
    theme(
      # Font across all text
      text = element_text(family = "Avenir"),
      
      # Titles + Text
      plot.title = element_text(hjust = 0, face = "bold", size = 20),
      plot.subtitle = element_text(size = 18),
      legend.title = element_text(size = 16, lineheight = 1.75),
      legend.text = element_text(size = 12), 
      legend.spacing.y = unit(1.75, "lines"),
      
      # Grids and Axes
      panel.background = element_blank(), 
      panel.border = element_rect(color = "black", fill = "transparent"), 
      panel.grid.major = element_line(color = "gray80"),
      axis.title.x = element_blank(),
      axis.title.y = element_blank(),
      axis.ticks=element_blank(),
      plot.margin = margin(t = 3, r = 3, b = 3, l = 3, unit = "pt"),
      legend.background = element_rect(
        color = "transparent", 
        fill = "white", 
        linewidth = 0.25),
      # Facets
      strip.background = element_rect(
        fill     = "#00736D", 
        color    = "white"),
      strip.text = element_text(
        color    = "white", 
        face     = "bold",
        size     = 12,
        family   = fontfam),
      legend.position = "bottom",
      
      # Use ellipses for tweaks on the fly:
      ...))
}




# Plot theme
```


```{r}
#| label: sf mesh making

# This was found in Create_Mesh_from_Knots.R
sf_meshify <- function(
    input_df, 
    coords = c("Lon", "Lat"), 
    length_km = 25, 
    in_crs = 4326, 
    trans_crs = 32619, 
    square = T){
  
  # Make the dataframe an sf class using coordinates
  in_sf <- st_as_sf(input_df, coords = coords, crs = in_crs, remove = F) %>% 
    # Transform it to a crs that is projected in meters
    st_transform(crs = trans_crs)
  
  # If we are getting gaps we can buffer here, or up the mesh size
  # Use that data to define a grid with dimensions of length_km*length_km
  sf_grid <- st_make_grid(
    x = in_sf,
    cellsize = c(length_km*1000, length_km*1000), 
    what = "polygons", 
    square = square) %>% 
    # Make the grid an sf class
    st_as_sf() 
  
  # Use the original data to trim it so its just cells that overlap the points
  sf_out <- sf_grid %>% 
    st_filter(in_sf, .predicate = st_contains) %>%
    st_as_sf() 
  
  # Join the clipped grid to the dataset
  sf_out <- st_join(sf_out, in_sf, join = st_intersects)
  # Return the results  
  return(sf_out)
  
}





# Joins the mesh, and summarises to get a mean if there is any duplicate points in the cells
rejoin_mesh <- function(locations_df, mesh){
  left_join(locations_df, mesh) %>% 
  st_as_sf() %>% 
  group_by(geometry) %>% 
  summarise_if(.predicate = is.numeric, .funs = mean)
}

```






# Understanding Single Species Projection Results



Andrew has been processing individual species distribution models for a suite of species that inhabit the Northeast US and Scotian shelf habitate. These models are developed using a combined catch dataset built from the US and Canadian fisheries independent trawl survey programs.

There are three model "types" being explored to investigate different model structures and their tradeoffs when applied for projected species distributions.


## Load sdmTMB Models

The models themselves provide details on the formula's used and can be used to produce marginal effects plots of the species preferences for depth and temperature.


```{r}
#| label: load sdm models

# Populate a list of the models in the local folder
# mods_path <- here::here("local_data/single_speciessdm_results/Fit_Mods")
mods_path <- str_c(cs_path("mills", "Projects/Single_Species_SDMs/Results"), "Fit_Mods")
mod_names <- str_remove_all(list.files(mods_path, pattern = ".rds"), ".rds")


# Load the different models
sdm_mods <- map(
  .x = list.files(mods_path, pattern = ".rds", full.names = T),
  .f = ~read_rds(.x)) %>%
  setNames(mod_names)

```



## Load Model Projections

The projections have been run for two SSP scenarios, which extend forward in time through 2100.

There are three main species which we have projection data for now:   
 * Cod   
 * Lobster   
 * Halibut   
 


```{r}
#| label: load Sdmtmb projections

# Load the projection data - sent over from Andrew

# # Projections Set 1
# projections_path <- paste0(crsbnd_path, "/projections/projections_may25")
# 
# # Get their names, without the _mean_projections.rds
# projection_names <- str_remove_all(
#   list.files(projections_path), 
#   pattern = "_mean_projections.rds")


# Eventually these below will also be moved on to box:

# Projections set 2
# Sent as a standalone zip folder with models
projections_path <- here::here("local_data/single_speciessdm_results/Projections")
projection_names <- str_remove_all(
  list.files(projections_path, pattern = ".rds"), 
  ".rds")


# Select a manageable subset for making a clearer comparison:
# the ones with underscores are the two recent ones
projections_subset <- which(str_detect(projection_names, "cod"))



# Load them up
projections <- list.files(
    projections_path, 
    full.names = T)[projections_subset] %>% 
  setNames(projection_names[projections_subset]) %>% 
  map_dfr(
    ~read_rds(.x) %>% 
      mutate(
        season = str_to_title(season),
        season = factor(
          season, 
          levels = season_levels)), 
    .id = "model_group")



# Split out the species, model type, and ssp scenario information
projections <- projections %>% 
  mutate(
    model_id = model_group,
    # ID scenario, remove from group
    scenario = if_else(
      str_detect(model_group, "SSP1|ssp1"), 
      "SSP1-2.6", "SSP5-8.5"),
    model_group = str_remove_all(
      model_group, 
      "_SSP1_26|_SSP5_85|ssp126|ssp585"),
    # Label the model structure
    model_type = case_when(
      str_detect(model_group, "_spst_seas_fac") ~ "Env + SP + SP_ST",
      str_detect(model_group, "_seas_fac") ~ "Env",
      str_detect(model_group, "_sp_st") ~ "SeasonSVC + SP + SP_ST",
      str_detect(model_group, "_sp") ~ "SeasonSVC + SP",
      str_detect(model_group, "_null") ~ "SeasonSVC"),
    # Remove the model type from group id, end up with species
    model_group = str_remove_all(
      model_group, "_sp_st|_sp|_null|_mean_projections|_seas_fac|_spst|_projs_|st"),
      model_group = str_to_title(model_group), 
    period = case_when(
      year %in% c(2004:2023) ~ "Baseline",
      year %in% c(2045:2054) ~ "Mid-Century",
      year %in% c(2090:2100) ~ "End-of Century",
      TRUE ~ "drop"),
    period = factor(period, levels = period_levels)) %>% 
  rename(species = model_group) %>% 
  # Get the upper and lower predictions using link scale
  mutate(
    proj_biomass_high = proj_biomass_mean + (1.96 * proj_biomass_se),
    proj_biomass_low  = proj_biomass_mean - (1.96 * proj_biomass_se),
    
    # Convert mean, upper, lower to response
    mean_response = exp(proj_biomass_mean),
    se_response   = exp(proj_biomass_se),
    response_high = exp(proj_biomass_high),
    response_low  = exp(proj_biomass_low))

# # Check
# projections %>% distinct(species, model_id)

```



### Make plotting mesh

This is not necessary, but people like the hexagons.

```{r}
#| label: make hex mesh

# Get unique Coordinates
unique_locations <- distinct(
  projections, longitude, latitude, area) %>% 
  st_as_sf(
    coords = c("longitude", "latitude"), 
    crs = 4326, remove = F)

# Make a mesh from the sdm locations
sdm_hex_grid <- sf_meshify(
  input_df = unique_locations, 
  square = F, 
  length_km = 35) %>% 
  rename(geometry = x)

# Add depth to the locations
bathy <- raster(str_c(cs_path("res","Bathy/"), "ETOPO1/NEShelf_Etopo1_bathy.tiff")) 

# Add bathymetry to the locations
unique_locations <- unique_locations %>% 
  mutate(depth = raster::extract(bathy, unique_locations))

```


### Assign Nationality Labels to Projections

For cross-boundary we are interested in differences between US and Canadian study areas. This section takes the unique projection locations and assigns the national jurisdiction that each location falls within.

```{r}

# Do the overlays to assign which region 
# each projection grid cell belongs too
# dfo_bounds
# nmfs_bounds

# Label which area the points fall within
dfo_locations <- st_join(
  unique_locations, 
  dfo_bounds, 
  join = st_within) %>% 
  filter(is.na(Region) == FALSE)
nmfs_locations <- st_join(
  unique_locations, 
  nmfs_bounds, 
  join = st_within) %>% 
  filter(is.na(Region) == FALSE)
region_labs <- bind_rows(
  dfo_locations, 
  nmfs_locations) %>% 
  st_drop_geometry() %>% 
  rename(jurisdiction = Region)


# Add these back in
projections <- left_join(projections, region_labs)

```




# Model Assesment

All of these models have `BT_seasonal_scaled` & `Depth_scaled`. More complex models will contain a global spatial term `SP`, & others will have a yearly spatial term: `SP + ST`.

We want to know how does the model performs, and what its behaviors are with:
 1. The data it was fit with   
 2. The leave-out validation data   
 3. When projected forward in time under different environmental conditions
 
 


# Fixed Effect Plots

All the models contain fixed effects of both bottom temperature and depth. These are global effects (one curve per model, not seasonally varying).

The following plots show whether these curves are centered around the same environmental conditions, or if the relationship to depth/temperature is shifting with the addition of other predictors.

These plots also show in some sense the relative influence that these fixed effects have over the response.


```{r}
#| label: pick a species

# Take one species as a tester:
# test_species <- "Halibut"
test_species <- "Cod"
# test_species <- "Lobster"
```



```{r}
#| label: fixed effect rescaling

# Load the rescaling values for / coca
rescale_df <- tribble(
  ~"covariate",   ~"gmean", ~"gsd",
  "Depth",         123.47, 100.2,
  "SST_seasonal",  11.11,  4.55,
  "BT_seasonal",   7,      2.72)

```


Preference curves below are produced by providing a prediction dataframe to the `predict()` function/method. 

For this, I set provide a range of values for the effecto of interest and a value of 0 for the other fixed effects. The predictors are scaled so this process holds the other effects at the mean value while exploring a range of values for the one we're interested in.


### Depth Preference

Depth is the simplest fixed effect to dig into. The relationship isn't interacting with anything, and depth is static so the impact of depth won't change moving forward with climate


```{r}
#| label: cod depth curve comparisons

# With this, I want to look at drift in the curve,
# and also change in the error/uncertainty around it

cod_mods <- list(
  "Env" = sdm_mods$cod_env_only,
  "Env + SeasFac" = sdm_mods$cod_seas_fac,
  "Env + SeasonSVC" = sdm_mods$cod_seas_svc,
  "Env + SP" = sdm_mods$cod_sp,
  "Env + SP + ST" = sdm_mods$cod_spst,
  "Env + SeasFac + SP + ST" = sdm_mods$cod_spst_seas_fac
  )



# Pull out the preference curve prediction from each of them
cod_depth_prefs <- imap_dfr(
  cod_mods,
  function(cod_mod_obj, mod_name){
    
    # Build prediction frame:
    # holds most model options constant while predicting over range of bottom temperatures
    bt_prediction_frame <- tibble(
        "year_season_int" = 1,
        "latitude" = cod_mod_obj$data$latitude[1],
        "longitude" = cod_mod_obj$data$longitude[1],
        "survey" = "NEFSC",
        "season" = "spring",
        "factor(season)spring" = 1,
        "factor(season)summer" = 0,
        "factor(season)fall" = 0,
        "Depth_scaled" = seq(-5,5, .05), 
        "BT_seasonal_scaled" = 0)
    
    # Use model to get predictions
    bt_pref_df <- predict(
      object = cod_mod_obj, 
      newdata = bt_prediction_frame,
      se_fit = F, 
      re_form = NA,
      re_form_iid = NA) %>% 
    mutate(
      model_type = mod_name,
      variable = "Depth",
      Depth_actual = (Depth_scaled*rescale_df[[1,3]]) + rescale_df[[1,2]],
      est_response = exp(est))#,
      # confmin = exp(est - 1.96*est_se),
      # confmax = exp(est + 1.96*est_se))
    
  }
) %>% 
  mutate(model_type = factor(model_type, levels = mod_levels))



# Plot them all
ggplot(cod_depth_prefs) +
  geom_area(aes(Depth_actual, est_response), alpha = 0.3) +
  geom_line(aes(Depth_actual, est_response)) +
  facet_wrap(
    ~model_type, scales = "fixed",
    labeller = labeller(model_type = label_wrap_gen(width = 8))) +
  labs(title = "Depth")


# # Plot them all, with error
# ggplot(cod_depth_prefs) +
#   geom_ribbon(aes(Depth_actual, ymin = confmin, ymax = confmax, fill = model_type), alpha = 0.3) +
#   geom_line(aes(Depth_actual, est_response, color = model_type)) +
#   labs(title = "Depth")


```


### Depth Effect Map


```{r}
#| label: depth preferences on map



# Choose the model to use
# mod_pick <- "cod_env_only"
mod_pick <- "cod_spst_seas_fac"


# Make a prediction frame for depth changes
depth_pred_frame <- unique_locations %>% 
  st_drop_geometry() %>% 
  mutate(
    year_season_int = 1,
    survey = "NEFSC",
    season = "spring",
    `factor(season)spring` = 1,
    `factor(season)summer` = 0,
    `factor(season)fall` = 0,
    Depth_scaled = ((-1*depth) - rescale_df[[1,2]] ) / rescale_df[[1,3]],
    BT_seasonal_scaled = 0) 




# Get the predictions
depth_map_preds <- predict(
    sdm_mods[[mod_pick]], 
    newdata = depth_pred_frame,
    se_fit = FALSE, 
    re_form = NA)  %>% 
    select(-c(season, survey, `factor(season)spring`, `factor(season)summer`, `factor(season)fall`)) %>% 
  mutate(
    Depth_actual = (Depth_scaled*rescale_df[[1,3]]) + rescale_df[[1,2]],
    est_response = exp(est))



# Map where the model places biomass by depth
depth_map_preds %>%
  mutate(model_type = mod_pick) %>% 
  # need to add back lat/lon for env only
  #bind_cols(depth_pred_frame[, c("longitude", "latitude")]) %>% 
  left_join(sdm_hex_grid) %>%
  st_as_sf() %>%
  ggplot() +
    # geom_sf(aes(fill = est), alpha = 0.8) + 
    geom_sf(aes(fill = est_response), alpha = 0.8) + 
    scale_fill_distiller(palette = "RdBu") +
    geom_sf(data = land_sf, color = "gray95", fill = "gray40", linewidth = 0.15) +
    geom_sf(data = hague_sf, color = "black", linewidth = 1, linetype = 1) +
    theme_map() +
    theme(
      legend.position = "bottom", 
      legend.title.position = "top") +
    guides(fill = guide_colorbar(barwidth = unit(10, "cm"))) +
    facet_wrap(~model_type) +
    coord_sf(
      xlim = c(-182500, 1550000), 
      ylim = c(3875000, 5370000) , 
      expand = F, crs = 32619) +
    labs(title = "Depth Marginal Effect on Map")


```





### Bottom Temperature


```{r}
#| label: Bottom Temperature preference curves

# With this, I want to look at drift in the curve,
# and also change in the error/uncertainty around it

# Pull out the preference curve prediction from each of them
cod_bt_prefs <- imap_dfr(
  cod_mods,
  function(cod_mod_obj, mod_name){
    
    # Build prediction frame:
    # holds most model options constant while predicting over range of bottom temperatures
    bt_prediction_frame <- tibble(
        "year_season_int" = 1,
        "latitude" = cod_mod_obj$data$latitude[1],
        "longitude" = cod_mod_obj$data$longitude[1],
        "survey" = "NEFSC",
        "season" = "spring",
        "factor(season)spring" = 1,
        "factor(season)summer" = 0,
        "factor(season)fall" = 0,
        "Depth_scaled" = 0, # Set to 0
        "BT_seasonal_scaled" = seq(-5,5, .05))
    
    # Use model to get predictions
    bt_pref_df <- predict(
      object = cod_mod_obj, 
      newdata = bt_prediction_frame,
      se_fit = F, 
      re_form = NA,
      re_form_iid = NA) %>% 
    mutate(
      model_type = mod_name,
      variable = "Bottom Temperature",
      BT_actual = (BT_seasonal_scaled*rescale_df[[3,3]]) + rescale_df[[3,2]],
      est_response = exp(est))#,
      # confmin = exp(est - 1.96*est_se),
      # confmax = exp(est + 1.96*est_se))
    }) %>% 
  mutate(model_type = factor(model_type, levels = mod_levels))



# Plot them all
ggplot(cod_bt_prefs) +
  geom_area(aes(BT_actual, est_response), alpha = 0.3) +
  geom_line(aes(BT_actual, est_response)) +
  facet_wrap(
    ~model_type, scales = "fixed",
      labeller = labeller(model_type = label_wrap_gen(width = 8)))+
  labs(title = "Bottom Temperature")


# Get the range of bottom temperature seen in the model-fitting data
bt_range <- sdm_mods[["cod_env_only"]]$data %>%
  group_by(season) %>% 
  summarise(BT_min = min(BT_seasonal_scaled),
            BT_max = max(BT_seasonal_scaled))


# Plot them all, overlay the ranges seen during model fit
select(cod_bt_prefs, -season)  %>% 
  ggplot() +
    geom_rect(
      data = bt_range,
      aes(
        xmin = (BT_min*rescale_df[[3,3]]) + rescale_df[[3,2]] ,
              xmax = (BT_max*rescale_df[[3,3]]) + rescale_df[[3,2]] ,
              ymin = -Inf,
              ymax = Inf, fill = season),
          alpha = 0.3) +
    geom_line(aes(BT_actual, est_response)) +
    facet_grid(
      season~model_type,
      labeller = labeller(model_type = label_wrap_gen(width = 8))) +
    labs(
      title = "Bottom Temperature",
      fill = "Temperature Range of Fitting Data")



# Plot One specific model
# select(cod_bt_prefs, -season)  %>% 
#   filter(model_type == "Env + SeasFac + SP + ST") %>% 
#   ggplot() +
#   geom_rect(
#     data = bt_range,
#     aes(
#       xmin = (BT_min*rescale_df[[3,3]]) + rescale_df[[3,2]] ,
#             xmax = (BT_max*rescale_df[[3,3]]) + rescale_df[[3,2]] ,
#             ymin = -Inf,
#             ymax = Inf, fill = season),
#         alpha = 0.3) +
#   geom_line(aes(BT_actual, est_response)) +
#   facet_grid(
#     season~model_type,
#     labeller = labeller(model_type = label_wrap_gen(width = 8))) +
#   labs(
#     title = "Bottom Temperature",
#     fill = "Temperature Range of Fitting Data")
```





### BT Reference Markers

For points of reference, the average seasonal temperatures within the US and Canada have been overlaid onto these curves


```{r}
#| label: US+DFO average seasonal temperatures

# Just pull BT from the projections to be quick
projected_mean_BTconditions <- projections %>% 
  filter(period != "drop") %>% 
  group_by(scenario, period, jurisdiction, season) %>% 
  summarise(
    Depth_scaled = mean(Depth_scaled, na.rm = T),
    BT_seasonal_scaled = mean(BT_seasonal_scaled, na.rm = T),
    .groups = "drop") %>% 
  mutate(
    variable = "Bottom Temperature",
    Depth_actual =  (Depth_scaled * rescale_df[[1,3]] ) + rescale_df[[1,2]],
    BT_actual =  (BT_seasonal_scaled * rescale_df[[3,3]] ) + rescale_df[[3,2]])



# Plot the Depth (static)
# Plot them together
cod_bt_prefs %>% 
  select(-season) %>% 
  ggplot() +
  geom_area(aes(BT_actual, est_response), fill = "lightgray", alpha = 0.8) + 
  geom_vline(
    data = projected_mean_BTconditions, 
    aes(xintercept = BT_actual, 
        color = season, linetype = jurisdiction),
    linewidth = 0.8) +
  scale_color_gmri() +
  #facet_nested(scenario*period~model_type) +
  facet_nested(
    model_type~scenario*period, 
    labeller = labeller(model_type = label_wrap_gen(width = 8)),
    scales = "free") +
  labs(
    title = "Regional Temperatures Relative to Temperature Preference",
    x = "Bottom Temperature",
    y = "Kg/KM2")

```


### Temp Preference Maps

I've prepared gridded outputs of mean/5th/95th percentiles for bottom temperatures based on our bias-corrected SSP5 ensemble. Below are maps of where temperature perferences align with mapped conditions.


```{r}
#| label: temp prediction grid from rasters

# # These are the bottom temperatures for different periods in time
# ensemble_period_btemp <- read_rds(here::here("local_data/CRSBND_CMIP6/SSP5_85/ensemble_period_averages/baseline_mid_end_century_bottemp.rds"))
# 
# 
# # Get the bottom temperatures for each season and period as one big table
# # Use unique locations to extract the temepratures at locations we want to predict
# ensemble_btemp_frames <- map_dfr(
#   ensemble_period_btemp,
#   # layer 1: period
#   function(ensemble_period){
#     
#     # Need to go one layer deeper
#     # layer 2: metric
#     map_dfr(
#       ensemble_period,
#       function(ensemble_stat){
#       
#       
#       # Extract values from the raster onto the unique points
#       select(unique_locations, longitude, latitude) %>% 
#         st_drop_geometry() %>% 
#         mutate(
#           Spring = raster::extract(ensemble_stat$Spring, unique_locations),
#           Summer = raster::extract(ensemble_stat$Summer, unique_locations),
#           Fall   = raster::extract(ensemble_stat$Fall, unique_locations)
#         )
#         
#       }, .id = "ensemble_stat")
#       
#     }, .id = "period") %>% 
#   mutate(
#     ensemble_stat = str_remove_all(ensemble_stat, "bot_temp_GLORYs_bias_corrected_")) %>%
#   pivot_longer(
#     cols = c(Spring, Summer, Fall), 
#     names_to = "season", 
#     values_to = "bottom_temp")%>% 
#   drop_na(bottom_temp)
# 
# 
# # Do some light filtering, only use mean
# btemp_frame_small <- ensemble_btemp_frames %>% 
#   filter(ensemble_stat == "mean")
# 
# 
#  # Prepare the information the model needs to predict
# temperature_prediction_frame <- btemp_frame_small %>% 
#   mutate(
#     year_season_int = 1,
#     survey = "NEFSC",
#     season = "spring",
#     `factor(season)spring` = 1,
#     `factor(season)summer` = 0,
#     `factor(season)fall` = 0,
#     Depth_scaled = 0, # Set to mean for this one
#     BT_seasonal_scaled = (bottom_temp - rescale_df[[3,2]]) / rescale_df[[3,3]])
```


```{r}
#| label: temp prediction grid from projections

# Use the projected bottom temperatures straight from
# the projections data
projection_temp_template <- projections %>% 
  filter(
    period != "drop",
    is.na(jurisdiction) == FALSE) %>%
  select(scenario, period, season, jurisdiction, latitude, longitude, Depth_scaled, BT_seasonal_scaled, area) %>% 
  group_by(
    scenario, period, latitude, longitude, jurisdiction, season, area) %>%  
  summarise(
    # Keep the depth along
    Depth_scaled_stash = mean(Depth_scaled, na.rm = T), 
    BT_seasonal_scaled = mean(BT_seasonal_scaled, na.rm = T),
    .groups = "drop") 



# Add the dummy variables we need to get marginal effects
temperature_prediction_frame <- projection_temp_template %>%
  mutate(
    year_season_int = 1,
    survey = "NEFSC",
    season = "spring",
    `factor(season)spring` = 1,
    `factor(season)summer` = 0,
    `factor(season)fall` = 0,
    # Set to mean for this one
    Depth_scaled = 0)

```


```{r}
#| label: single model temperature marginal map

# Get the predictions
#mod_pick <- "Cod_env_only"
mod_pick <- "cod_spst_seas_fac"
temp_map_preds <- predict(
    sdm_mods[[mod_pick]], 
    #sdm_mods[[str_c(test_species,"_null")]], 
    #sdm_mods$Cod_spst_noSVC, 
     newdata = temperature_prediction_frame,
    se_fit = FALSE, 
    re_form = NA)  %>% 
    select(-c(season, survey, `factor(season)spring`, `factor(season)summer`, `factor(season)fall`)) %>% 
  mutate(
    Btemp_actual = (BT_seasonal_scaled*rescale_df[[3,3]]) + rescale_df[[3,2]],
    est_response = exp(est))

 

# Map where the model places biomass by depth
temp_map_preds %>%
  bind_cols(
    select(projection_temp_template, season)) %>%
  left_join(sdm_hex_grid) %>%
  st_as_sf() %>%
  mutate(
    model_type = mod_pick,
    period = factor(period, levels = period_levels),
    season = factor(season, levels = season_levels)) %>% 
  ggplot() +
    geom_sf(aes(fill = est_response), alpha = 0.8) + 
    scale_fill_distiller(palette = "RdBu") +
    geom_sf(data = land_sf, color = "gray95", fill = "gray40", linewidth = 0.15) +
    geom_sf(data = hague_sf, color = "black", linewidth = 1, linetype = 1) +
    theme_map() +
    theme(
      legend.position = "bottom", 
      legend.title.position = "top") +
    guides(fill = guide_colorbar(barwidth = unit(10, "cm"))) +
    coord_sf(
      xlim = c(-182500, 1550000), 
      ylim = c(3875000, 5370000) , 
      expand = F, crs = 32619) +
  facet_nested(scenario~model_type*period*season) +
  labs(title = "BT Marginal Effects on Map",
       subtitle = "Baseline, Mid-Century, and End-of Century")

```



# Marginal Effect Suite/Scorecard?

After thinking things through a bit, I think I want to condense the information of a few different figures into one plot.

For this summary figure: 
y axis is the marginal effect of a predictor
x axis is the different predictor
for bottom temperature



To do this, I would feed prediction frames to each model that contain the baseline period, mid-century, and end-of century mean temperatures. Then I would repeat this using the depths for a one-time depth marginal effect.

I don't know how to isolate the others, and I think that maybe a coefficient table will do a similar thing for us, so this is something on pause.



```{r}
#| label: process tables for both fixed effects

# Pass this to all the models
# then use group_by to get the average effect
# this should be weighted later by the area associated with each knot

# # Essentially we're mapping over the models
# fixed_marginal_effects_test <- imap_dfr(
#   cod_mods,
#   function(cod_mod_obj, mod_name){
#     
#     # Prediction Frames
#     bt_prediction_frame    <- temperature_prediction_frame
#     depth_prediction_frame <- depth_pred_frame
#     
#     # Use model to get predictions for bottom temperature
#     bt_pref_df <- predict(
#       object = cod_mod_obj, 
#       newdata = bt_prediction_frame,
#       se_fit = T, 
#       re_form = NA,
#       re_form_iid = NA) %>% 
#     mutate(
#       model_type = mod_name,
#       variable = "Bottom Temperature",
#       est_response = exp(est),
#       confmin = exp(est - 1.96*est_se),
#       confmax = exp(est + 1.96*est_se)) %>% 
#       # Drop all the things we held constant with dummy values
#       select(
#         -c(season, survey, `factor(season)spring`, 
#            `factor(season)summer`, `factor(season)fall`,
#            Depth_scaled, BT_seasonal_scaled))
#     
#     
#     # env only model drops lat/lon columns, need to add back
#     if(mod_name == "env_only"){
#       bt_pref_df <- bind_cols(
#         bt_pref_df, 
#         select(bt_prediction_frame, longitude, latitude)
#         )
#     }
#     
#     
#     # Rejoin the season details for temperature
#     bt_pref_df <- bt_pref_df  %>%
#       bind_cols(select( bt_prediction_frame, season)) %>% 
#       mutate(fe = str_c(variable, season, sep = " - "))
#     return(bt_pref_df)
#     
#     
#     #---- Depth
#     
#     # # Repeat the steps again for depth
#     # # Use model to get predictions for bottom temperature
#     # depth_pref_df <- predict(
#     #   object = cod_mod_obj,
#     #   newdata = depth_prediction_frame,
#     #   se_fit = T,
#     #   re_form = NA,
#     #   re_form_iid = NA) %>%
#     # mutate(
#     #   model_type = mod_name,
#     #   variable = "Depth",
#     #   est_response = exp(est),
#     #   confmin = exp(est - 1.96*est_se),
#     #   confmax = exp(est + 1.96*est_se)) %>%
#     #  # Drop all the things we held constant with dummy values
#     #   select(
#     #     -c(season, survey, `factor(season)spring`, 
#     #        `factor(season)summer`, `factor(season)fall`,
#     #        Depth_scaled, BT_seasonal_scaled)) %>% 
#     #   mutate(fe = str_c(variable))
#     # 
#     # # env only model drops lat/lon columns, need to add back
#     # if(mod_name == "env_only"){
#     #   depth_pref_df <- bind_cols(
#     #     bt_pref_df, 
#     #     select(depth_prediction_frame, longitude, latitude)
#     #     )
#     # }
#     # 
#     # 
#     # # # Bind to depth and bottom temperature details
#     # return(bind_rows(
#     #   bt_pref_df,
#     #   depth_pref_df
#     # ))
#     
#     
#   }
# )
# 
# 
# 
# 
# # Now we need to aggregate over the jurisdictions to get the average effect
# fixed_marginal_effects_test %>% distinct(variable)
# marg_effect_summary <- fixed_marginal_effects_test %>% 
#   left_join(region_labs) %>% 
#   mutate(period = if_else(variable == "Depth", "Static - No Change", period)) %>% 
#   group_by(model_type,period, jurisdiction, season, fe) %>% 
#   summarise(
#     est = weighted.mean(est, na.rm = T),
#     est_se = weighted.mean(est_se, na.rm = T),
#     est_response = weighted.mean(est_response, w = area, na.rm = T),
#     confmin = weighted.mean(confmin, w = area, na.rm = T),
#     confmax = weighted.mean(confmax, w = area, na.rm = T),
#     .groups = "drop")
# 
# 
# 
# # Plot those
# marg_effect_summary %>% 
#   mutate(
#     species = "Cod",
#     fe = factor(
#       fe, 
#       levels = c(
#         "Depth", 
#         str_c(
#           "Bottom Temperature - ",
#           c("Spring", "Summer", "Fall")))),
#     season = factor(season, levels = season_levels),
#     period = factor(period, levels = c("Static - No Change","baseline", "mid-century", "end-of century"))) %>%
#   ggplot() +
#     geom_segment(
#       aes(x = fe, xend = fe, 
#           y = confmin,
#           yend = confmax,
#           color = jurisdiction)) +
#     geom_point(aes(fe, est_response, color = jurisdiction)) + 
#   scale_color_gmri() +
#     facet_nested(
#       model_type~species*period,
#       labeller = labeller(model_type = label_wrap_gen(width = 8)),
#       scales = "free_x") +
#     theme(axis.text.x = element_text(angle = 90)) +
#     labs(
#       title = "Cod Marginal Effects",
#       y = "Regional Marginal Effect (Kg/km2)")
```






# Biomass Density Maps

The following maps show the mean predicted biomass/km2 densities for three periods in time: a baseline period, a mid-century period, and the end of the century.

## Baseline Period

For these maps a baseline period of the most recent 20 years is used (2004-2023) as a benchmark for comparison.


```{r}
#| fig-height: 8

# Filter to one species
single_species_projections <- projections %>% 
  filter(species ==  test_species)

# Get the average cpue over the most recent 20 years
single_species_baselines <-  single_species_projections %>% 
  filter(period != "drop") %>% 
  group_by(period, jurisdiction, species, model_type, scenario, season, longitude, latitude) %>% 
  summarise(
    biomass_mean = mean(exp(proj_biomass_mean), na.rm = T),
    .groups = "drop") %>% 
  pivot_wider(names_from = period, values_from = biomass_mean) %>% 
  mutate(
    mid_century_change = `Mid-Century` - Baseline,
    end_century_change = `End-of Century` - Baseline)



# Map the Baseline Period CPUE
single_species_baselines %>% 
  # Add context for symbology
  mutate(
    # 1. Highlight cases of range expansion or decline
    distribution_edge = case_when(
      Baseline < 1     ~ "Biomass < 1kg/km2",
      Baseline > 10    ~ "Biomass > 10kg/km2",
      TRUE ~ NA)) %>% 
  left_join(sdm_hex_grid) %>%
  st_as_sf() %>%
  ggplot() +
  geom_sf(
    aes(
      fill = Baseline,
      color = distribution_edge),
        linewidth = 0.2) +
  geom_sf(
    data = land_sf, color = "gray95", fill = "gray40", linewidth = 0.15) +
  geom_sf(data = hague_sf, color = "black", linewidth = 1, linetype = 1) +
   scale_color_manual(
    values = c(
    "Biomass < 1kg/km2" = "white",
    "Biomass > 10kg/km2" = "black"), 
    na.value = "transparent",
    na.translate = F) +
  rcartocolor::scale_fill_carto_c(
    palette = "RedOr", 
    limits = c(0, 10),
    oob = oob_squish,
    na.value = "transparent") +
  facet_nested(model_type*scenario~species*season, 
    labeller = labeller(model_type = label_wrap_gen(width = 8))) +
  theme_map() +
  theme(
    legend.position = "bottom", 
    legend.title.position = "top") +
  guides(
    fill = guide_colorbar(barwidth = unit(10, "cm")),
    color = guide_legend(
      nrow = 2,
      override.aes = list(
        linewidth = 1,
        fill = c("#F6D2A9", "#B13F64")))) +
  coord_sf(
    xlim = c(-182500, 1550000), 
    ylim = c(3875000, 5370000) , 
    expand = F, crs = 32619) +
  labs(
    title = "Baseline Period (2004-2023)",
    fill = "Biomass CPUE kg/km2",
    color = "Distribution Edges")

```


### Mid-Century Biomass Map

For mid-century I have averaged the projections over a ten-year period centered on 2050 (2045-2054).


```{r}
 
# Map the Baseline Period CPUE
single_species_baselines %>% 
  mutate(
    # 1. Highlight cases of range expansion or decline
    distribution_edge = case_when(
      `Mid-Century` < 1     ~ "Biomass < 1kg/km2",
      `Mid-Century` > 10  ~ "Biomass > 10kg/km2",
      TRUE ~ NA)) %>% 
  left_join(sdm_hex_grid) %>%
  st_as_sf() %>%
  ggplot() +
  geom_sf(
    aes(
      fill = `Mid-Century`,
      color = distribution_edge),
        linewidth = 0.2) +
  geom_sf(
    data = land_sf, color = "gray95", fill = "gray40", linewidth = 0.15) +
  geom_sf(
    data = hague_sf, color = "black", 
    linewidth = 1, linetype = 1) +
  scale_color_manual(
    values = c(
    "Biomass < 1kg/km2" = "white",
    "Biomass > 10kg/km2" = "black"), 
    na.value = "transparent",
    na.translate = F) +
  rcartocolor::scale_fill_carto_c(
    palette = "RedOr", 
    limits = c(0, 10),
    oob = oob_squish,
    na.value = "transparent") +
  #facet_nested(model_type*scenario~species*season, 
  facet_nested(model_type*scenario~species*season, 
    labeller = labeller(model_type = label_wrap_gen(width = 8))) +
  theme_map() +
  theme(
    legend.position = "bottom", 
    legend.title.position = "top") +
  guides(
    fill = guide_colorbar(barwidth = unit(10, "cm")),
    color = guide_legend(
      nrow = 2,
      override.aes = list(
        linewidth = 1,
        fill = c("#F6D2A9", "#B13F64")))) +
  coord_sf(
    xlim = c(-182500, 1550000), 
    ylim = c(3875000, 5370000) , 
    expand = F, crs = 32619) +
  labs(
    title = "Mid-Century (2045-2054)",
    fill = "Biomass CPUE kg/km2")

```

### Mid-Century Change

For mid-century change, I've mapped what the difference is between the mid-century averages and the baseline period.

Areas that had very low biomass in the baseline and now show some biomass I've highlighted as range gains. For areas where there is very low mid-century biomass that once had meaningful levels in the baseline period, I've labeled these as range losses. 

```{r}
 
# Map of mid-century changes
single_species_baselines %>% 
  # filter(model_type == "Env") %>% 
  # Add context for symbology
  mutate(
      # 1. Highlight cases of range expansion or decline
      range_shift = case_when(
        Baseline < 1 & `Mid-Century` > 1 ~ "Range Gained",
        Baseline > 1 & `Mid-Century` < 1 ~ "Range Lost",
        TRUE ~ NA),
      # Hide minor changes using alpha - should be done based off base biomass
      minor_change = case_when(
        between(mid_century_change, -.1,.1) ~ 0.3,
        between(mid_century_change, -.15,.15) ~ 0.4,
        between(mid_century_change, -.25, .25) ~ 0.6,
        between(mid_century_change, -.75, .75) ~ 1,
        mid_century_change > 1 ~ 1,
        mid_century_change < -1 ~ 1,
        TRUE ~ 0)#,
      # Fully Hide places that don't have measurable biomass in future state,
      #mid_century_change = ifelse(`Mid-Century` < 1, NA, mid_century_change)
      ) %>% 
  left_join(sdm_hex_grid) %>%
  st_as_sf() %>%
  ggplot() +
  geom_sf(
    aes(
      fill = mid_century_change,
      alpha = I(minor_change),
      color = range_shift),
    linewidth = 0.2) +
  scale_color_manual(values = c(
    "Range Gained" = "#008080",
    "Range Lost" = "#CA562C"), 
    na.value = "transparent",
    na.translate = F) +
  geom_sf(
    data = land_sf, color = "gray95", fill = "gray40", linewidth = 0.15) +
  geom_sf(
    data = hague_sf, color = "black", 
    linewidth = 1, linetype = 1) +
  rcartocolor::scale_fill_carto_c(
    palette = "Geyser", 
    limits =  c(-2,2) *
      quantile(
        abs(single_species_baselines$end_century_change), 
        probs = c(0.85), na.rm = T),
    oob = oob_squish, 
    breaks = pretty_breaks(n = 5),
    na.value = "transparent",
    direction = -1) +
  # facet_nested(
  #   model_type~species*scenario) +
  facet_nested(model_type*scenario~species*season,
    labeller = labeller(model_type = label_wrap_gen(width = 8))) +
  theme_map() +
  theme(
    legend.position = "bottom", 
    legend.title.position = "top") +
  guides(
    color = guide_legend(override.aes = list(linewidth = 1)),
    fill = guide_colorbar(barwidth = unit(10, "cm"))) +
  coord_sf(
    xlim = c(-182500, 1550000), 
    ylim = c(3875000, 5370000) , 
    expand = F, crs = 32619) +
  labs(
    title = "Mid-Century Biomass Change (2045-2054)",
    fill = "Difference in Biomass Density (kg/km2)",
    color = "Range Changes")


```




### End of Century Biomass

```{r}
 
# Map the Baseline Period CPUE
single_species_baselines %>% 
  mutate(
    # 1. Highlight cases of range expansion or decline
    distribution_edge = case_when(
      `End-of Century` < 1     ~ "Biomass < 1kg/km2",
      `End-of Century` > 10  ~ "Biomass > 10kg/km2",
      TRUE ~ NA)) %>% 
  left_join(sdm_hex_grid) %>%
  st_as_sf() %>%
  ggplot() +
  geom_sf(
    aes(
      fill = `End-of Century`,
      color = distribution_edge),
    linewidth = 0.2) +
  geom_sf(
    data = land_sf, color = "gray95", 
    fill = "gray40", linewidth = 0.15) +
  geom_sf(
    data = hague_sf, color = "black", 
    linewidth = 1, linetype = 1) +
  scale_color_manual(
    values = c(
    "Biomass < 1kg/km2" = "white",
    "Biomass > 10kg/km2" = "black"), 
    na.value = "transparent",
    na.translate = F) +
  rcartocolor::scale_fill_carto_c(
    palette = "RedOr", 
    limits = c(0, 10),
    oob = oob_squish,
    na.value = "transparent") +
  #facet_nested(model_type*scenario~species*season, 
  facet_nested(model_type*scenario~species*season, 
    labeller = labeller(model_type = label_wrap_gen(width = 8))) +
  theme_map() +
  theme(
    legend.position = "bottom", 
    legend.title.position = "top") +
  guides(
    fill = guide_colorbar(barwidth = unit(10, "cm")),
    color = guide_legend(
      nrow = 2,
      override.aes = list(
        linewidth = 1,
        fill = c("#F6D2A9", "#B13F64")))) +
  coord_sf(
    xlim = c(-182500, 1550000), 
    ylim = c(3875000, 5370000) , 
    expand = F, crs = 32619) +
  labs(
    title = "End of Century (2090-2100)",
    fill = "Biomass CPUE kg/km2")

```

### End of Century Change


```{r}
 
# Map of end-ofcentury changes
single_species_baselines %>% 
  # Add context for symbology
  mutate(
      # 1. Highlight cases of range expansion or decline
      range_shift = case_when(
        Baseline < 1 & `End-of Century` > 1 ~ "Range Gained",
        Baseline > 1 & `End-of Century` < 1 ~ "Range Lost",
        TRUE ~ NA),
      # Hide minor changes using alpha - should be done based off base biomass
      minor_change = case_when(
        between(end_century_change, -.1, .1) ~ 0.3,
        between(end_century_change, -.15, .15) ~ 0.4,
        between(end_century_change, -.25, .25) ~ 0.6,
        between(end_century_change, -.75, .75) ~ 1,
        end_century_change > 1 ~ 1,
        end_century_change < -1 ~ 1,
        TRUE ~ 0)#,
      # Fully Hide places that don't have measurable biomass in future state,
      # end_century_change = ifelse(`End-of Century` < 1, NA, end_century_change)
      ) %>% 
  left_join(sdm_hex_grid) %>%
  st_as_sf() %>%
  ggplot() +
  geom_sf(
    aes(
      fill = end_century_change,
      alpha = I(minor_change),
      color = range_shift),
    linewidth = 0.2) +
  geom_sf(
    data = land_sf, color = "gray95", 
    fill = "gray40", linewidth = 0.15) +
  geom_sf(
    data = hague_sf, color = "black", 
    linewidth = 1, linetype = 1) +
  scale_color_manual(values = c(
    "Range Gained" = "#008080",
    "Range Lost" = "#CA562C"), 
    na.value = "transparent",
    na.translate = F) +
  rcartocolor::scale_fill_carto_c(
    palette = "Geyser", 
    limits =  c(-2,2) *
      quantile(
        abs(single_species_baselines$end_century_change), 
        probs = c(0.85), na.rm = T),
    oob = oob_squish, 
    breaks = pretty_breaks(n = 5),
    na.value = "transparent",
    direction = -1) +
  #facet_nested(model_type*scenario~species*season, 
  facet_nested(model_type*scenario~species*season, 
    labeller = labeller(model_type = label_wrap_gen(width = 8))) +
  theme_map() +
  theme(
    legend.position = "bottom", 
    legend.title.position = "top") +
  guides(
    color = guide_legend(override.aes = list(linewidth = 1)),
    fill = guide_colorbar(barwidth = unit(10, "cm"))) +
  coord_sf(
    xlim = c(-182500, 1550000), 
    ylim = c(3875000, 5370000) , 
    expand = F, crs = 32619) +
  labs(
    title = "End-of Century Biomass Change (2090-2100)",
    fill = "Biomass CPUE kg/km2",
    color = "Range Changes")

```




# Biomass Timeseries

See the biomass changes (overall, US, Can) as time series over years for the outputs of different model structures and forward-projection methods within the s-t structure

For the whole USA + Canada Region, here is what the timeseries for a single species' projected biomass could resemble



### Overall Biomass

```{r}
#| label: process timeseries link scale

# Average density within each region per time step
projections_total_area <- sum(unique_locations$area)
overall_summ <- projections |>
  group_by(species, model_type, scenario, season, year, date) |>
  # Get the average of the mean, high, and low estimates
  # weight them by the area column
  summarize(
    mean_biomass = weighted.mean(mean_response, w = area, na.rm = T), 
    high_est     = weighted.mean(response_high, w = area, na.rm = T),
    low_est      = weighted.mean(response_low,  w = area, na.rm = T),
    .groups = "drop") %>% 
  # Multiply those kg/km densities by the total area
  mutate(
    biomass_total   = mean_biomass * projections_total_area,
    biomass_uplim   = high_est * projections_total_area,
    biomass_downlim = low_est * projections_total_area)

```



```{r}
# If it turns out we're fine
overall_summ %>% 
  #filter(model_type != "SeasonSVC + SP + SP_ST") %>% 
  ggplot() +
  geom_vline(xintercept = 2023, lty = "dashed") +
  geom_ribbon(
    aes(x = year, 
        ymin = biomass_downlim, 
        ymax = biomass_uplim, fill = model_type), alpha = 0.4) +
  geom_line(
    aes(x = year,
        y = biomass_total, color = model_type),
    lwd = 1) +
  geom_vline(xintercept = 2023, lty = "dashed") +
  scale_color_gmri() +
  scale_fill_gmri() +
  scale_y_continuous(
    transform = transform_log10(),
    labels = label_log(base = 10)) +
  facet_nested(
    season~species*scenario, 
    labeller = labeller(model_type = label_wrap_gen(width = 8)),
    scales = "free",
    nest_line = TRUE) +
  labs(
    title = "Overall Biomass Timeseries", 
    x = "Year", y = "Projected Total Biomass",
    color = "Model Structure",
    fill = "Model Structure")


```



### Territory Timeseries

Within each national jurisdiction (USA, CAN) we can estimate the total biomass from the predicted densities from the model.


```{r}
#| label: territory summary new


# Get the upper/lower projection for each location
territory_summary <-  projections |>
    # mutate(
      # # Check Andrew's way
      # proj_biomass_log = proj_biomass_mean + log(area),
      # lwr0.1_log = (proj_biomass_mean - qnorm(0.9) * proj_biomass_se) + log(area),
      # upr0.9_log = (proj_biomass_mean + qnorm(0.9) * proj_biomass_se) + log(area),
      # proj_biomass_resp = exp(proj_biomass_log),
      # lwr0.1_resp = exp(lwr0.1_log),
      # upr0.9_resp = exp(upr0.9_log)
      # ) %>% 
    group_by(species, jurisdiction, model_type, scenario, season, year, date) |>
    
    # Get the average of the mean, high, and low estimates
    # weight them by the area column
    summarize(
      mean_biomass = weighted.mean(mean_response, w = area, na.rm = T), 
      high_est     = weighted.mean(response_high, w = area, na.rm = T),
      low_est      = weighted.mean(response_low,  w = area, na.rm = T),
      
      # # # Check Andrew's way
      # proj_bio_total_log  = sum(proj_biomass_log, na.rm = TRUE),
      # proj_bio_lwr_log    = sum(lwr0.1_log, na.rm = TRUE),
      # proj_bio_upr_log    = sum(upr0.9_log, na.rm = TRUE),
      # proj_bio_total_resp = sum(proj_biomass_resp, na.rm = TRUE),
      # proj_bio_lwr_resp   = sum(lwr0.1_resp, na.rm = TRUE),
      # proj_bio_upr_resp   = sum(upr0.9_resp, na.rm = TRUE),
      
      .groups = "drop") %>% 
  
  # Add the different regions in
  left_join(
    st_drop_geometry(select(all_regs, -area, geometry)), 
    join_by(jurisdiction)) %>% 
  
  # Multiply those kg/km densities by the total area
  mutate(
    biomass_total   = mean_biomass * drop_units(regional_area),
    biomass_uplim   = high_est * drop_units(regional_area),
    biomass_downlim = low_est * drop_units(regional_area)) %>% 
  
  # Get fraction of total by summing over the major groups
  group_by(species, model_type, scenario, season, year, date) %>% 
  mutate(full_region_biomass = sum(biomass_total, na.rm = T)) %>% 
  ungroup() %>% 
  mutate(frac_total = biomass_total / full_region_biomass)


# # Confirm that andrew and I's stuff works
# ggplot(territory_summary) +
#   geom_line(aes(year, proj_bio_total_resp, color = "Andrew")) +
#   #geom_line(aes(year, biomass_total, color = "Adam")) +
#   scale_color_gmri() +
#   facet_nested(
#       model_type*scenario~species*season, 
#       labeller = labeller(model_type = label_wrap_gen(width = 8)),
#       scales = "free")  +
#     labs(
#       title = "Total Estimated Biomass",
#       x = "Year", y = "Projected Total Biomass")
  
```



```{r}
#| label: plot territory summary

# Plot them all
territory_summary %>% 
  ggplot() +
    geom_ribbon(
      aes(x = year, ymin = biomass_downlim, ymax = biomass_uplim, 
          fill = jurisdiction), alpha = 0.2) +
    geom_line(
      aes(x = year,
          y = biomass_total,
          color = jurisdiction)) +
    geom_vline(xintercept = 2019, lty = "dashed") +
    scale_color_manual(
      values = c("DFO" = "#D80621", "NMFS"= "#002868"))  +
    scale_fill_manual(
      values = c("DFO" = "#D80621", "NMFS"= "#002868"))  +
    scale_y_continuous(
      transform = transform_log10(),
      labels = label_log(base = 10)) +
    facet_nested(
      model_type*scenario~species*season,
      labeller = labeller(model_type = label_wrap_gen(width = 8)),
      scales = "free",
    nest_line = TRUE)  +
    labs(
      title = "Projected Biomass Totals",
      x = "Year", y = "Projected Total Biomass",
      color = "Government Jurisdiction",
      fill = "Government Jurisdiction")

```

### Territory Proportions

What side of the hague line is most of the biomass located within?

```{r}
# Plot them all
territory_summary %>% 
  # filter(model_type == "Env") %>% 
  ggplot() +
    geom_area(
      aes(x = year, 
          y = frac_total, 
          color = jurisdiction,
          fill = jurisdiction),
      alpha = 0.4) +
    geom_vline(xintercept = 2019, lty = "dashed") +
    scale_color_manual(values = c("DFO" = "#D80621", "NMFS"= "#002868")) + 
    scale_fill_manual(values = c("DFO" = "#D80621", "NMFS"= "#002868")) + 
  scale_x_continuous(expand = expansion(add = c(0,0))) +
    scale_y_continuous(
      labels = label_percent(), 
      expand = expansion(add = c(0,0))) +
    facet_nested(scenario*model_type~species*season, 
        labeller = labeller(model_type = label_wrap_gen(width = 8)),
        scales = "free",
        nest_line = TRUE)  +
    labs(
      title = "Estimated Biomass within Each Territory",
      x = "Year", y = "Total Biomass",
      fill = "Management Jurisdiction",
      color = "Management Jurisdiction")
```


### Mid/Late Century Percent Differences

These still need to be converted to the right units


```{r}
#| label: period summary prep

# Need to reshape this into period summaru
period_summ <- projections %>% 
  filter(period != "drop") %>% 
  group_by(model_type, season, period, jurisdiction, scenario) |>
  # Get the average of the mean, high, and low estimates
  # weight them by the area column
  summarize(
    mean_biomass = weighted.mean(mean_response, w = area, na.rm = T), 
    high_est     = weighted.mean(response_high, w = area, na.rm = T),
    low_est      = weighted.mean(response_low,  w = area, na.rm = T),
    .groups = "drop") %>% 
  # Add the different regions in
  left_join(
    st_drop_geometry(select(all_regs, -area, geometry)), 
    join_by(jurisdiction)) %>%
  # Multiply those kg/km densities by the total area
  mutate(
    biomass_total   = mean_biomass * drop_units(regional_area),
    biomass_uplim   = high_est * drop_units(regional_area),
    biomass_downlim = low_est * drop_units(regional_area)) 

  


# Reshape? We want the periods as columns so we can get differences
period_differences <- period_summ %>% 
  select(-c(mean_biomass, high_est, low_est, biomass_uplim, biomass_downlim)) %>% 
  pivot_wider(
    names_from = period, 
    values_from = biomass_total) %>%
  mutate(
    mid_change = `Mid-Century` - Baseline,
    end_change = `End-of Century` - Baseline,
    mid_change_percent = mid_change/Baseline,
    end_change_percent = end_change/Baseline)


```


```{r}
#| label: difference in period plots

# Do some major reshaping
chicklet_prep <- period_differences %>% 
  # Plot percent differences, so drop the other columns
  select(-c(
    Baseline, `Mid-Century`, mid_change, `End-of Century`, end_change)) %>% 
  pivot_longer(
    cols = ends_with("percent"), 
    names_to = "period", 
    values_to = "percent_change") %>% 
  mutate(
    bar_x = if_else(jurisdiction == "DFO", 1, 1.1),
    bar_y = if_else(jurisdiction == "DFO", 1, 1.1),
     period_label = if_else(
      str_detect(period, "mid"), "Mid-Century", "Turn of the Century")) %>%
  pivot_wider(
    names_from = model_type, 
    values_from = "percent_change") %>% #glimpse()
  mutate(label_x = (Env + `Env + SP + SP_ST`)/2)


# Plot that
bar_height <- 0.025
ggplot(chicklet_prep) +
  geom_vline(xintercept = 0, linewidth = 0.8, color = "gray60") +
  ggchicklet:::geom_rrect(
    aes(
      xmin = `Env + SP + SP_ST`,
      xmax = Env, 
      ymin = bar_y - bar_height, 
      ymax = bar_y + bar_height, 
      fill = jurisdiction),
    r = unit(0.25, 'npc')) +
  geom_point(
    data = chicklet_prep,
    aes(x = Env, y = bar_y, shape = "Environment\nOnly Model"), 
    size = 3, fill = "white") +
  geom_point(
    data = chicklet_prep,
    aes(x = `Env + SP + SP_ST`, y = bar_y, shape = "Spatio-Temporal\nModel"), 
    size = 3, fill = "white") +
  facet_nested(
    period_label + season ~ scenario,
    nest_line = TRUE) +

  scale_shape_manual(values = c(21, 24)) +
  scale_x_continuous(
    limits = c(-1,1), 
    labels = label_percent()) +
  scale_y_continuous(expand = expansion(mult = c(0.75,0.75))) +
  scale_fill_gmri() +
  theme_minimal() +
  theme(
    text = element_text(family = "Avenir"),
    legend.position = "bottom",
    legend.title.position = "left",
    axis.text.y = element_blank(),
    legend.title = element_text(size = 12, face = "bold"),
    panel.grid.major.y = element_blank(),
    strip.text = element_text(family = "Avenir", face = "bold", size = 12),
    legend.box = "Vertical") +
  labs(
    x = "Biomass Change",
    fill = "National Jurisdiction:", 
    y = "",
    title = "Projected Regional Biomass Changes",
    subtitle = "Percent difference from 2004-2023 Baseline Period",
    shape = "Distribution Model Type:")
  
```



```{r}
#| label: chicklet wide



# Plot that
bar_width <- 0.0025
ggplot(chicklet_prep) +
  geom_hline(yintercept = 0, linewidth = 0.8, color = "gray60") +
  ggchicklet:::geom_rrect(
    aes(
      ymin = `Env + SP + SP_ST`,
      ymax = Env, 
      xmin = bar_x - bar_width, 
      xmax = bar_x + bar_width, 
      fill = jurisdiction),
    r = unit(0.45, 'npc')) +
  geom_point(
    data = chicklet_prep,
    aes( x = bar_x,y = Env, shape = "Environment\nOnly Model"), 
    size = 3, fill = "white") +
  geom_point(
    data = chicklet_prep,
    aes(x = bar_x, y = `Env + SP + SP_ST`,  shape = "Spatio-Temporal\nModel"), 
    size = 3, fill = "white") +
  facet_nested(
    season * scenario ~ period_label,
    nest_line = TRUE) +
  scale_shape_manual(values = c(21, 24)) +
  scale_y_continuous(
    limits = c(-1,1), 
    labels = label_percent()) +
  scale_x_continuous(expand = expansion(mult = c(0.75,0.75))) +
  scale_fill_gmri() +
  theme(
    axis.ticks.x = element_blank(),
    axis.text.x = element_blank()) +
  labs(
    x = "Jurisdiction",
    fill = "National Jurisdiction:", 
    y = "Percent Biomass Change",
    title = "Projected Regional Biomass Changes",
    subtitle = "Percent difference from 2004-2023 Baseline Period",
    shape = "Distribution Model Type:")
```

 
# Center of Gravity

 4. See the COG changes (across whole domain) as a time series over years for the outputs of different model structures and forward-projection methods within the s-t structure
 
 
```{r}
#| label: sdm_tmb center of gravity function


# Center of gravity as weighted mean
response_scale_COGrav <- function(df, biomass_col, lon_col = "longitude", lat_col = "latitude") {
    cog_lat<- weighted.mean(
      df[,lat_col], 
      w = df[, biomass_col], 
      na.rm = T)
    cog_lon<- weighted.mean(
      df[,lon_col], 
      w = df[, biomass_col], 
      na.rm = T)
    # Return as a dataframe
    cog_out <- data.frame(
      "COGx" = cog_lon, 
      "COGy" = cog_lat)
    return(cog_out)}
```


```{r}
#| label: estimate centers of gravity
#| eval: true


# Estimate center of gravity
single_species_cog <- projections |>
    mutate(biomass_total = mean_response * area) %>% 
    group_by(model_id, period, model_type, scenario, season, year, species) |>
    nest() %>% 
    mutate(
      ID = row_number(),
      COG = map(data, ~ response_scale_COGrav(.x, biomass_col = "biomass_total"))) |>
    unnest_wider(COG) %>% 
  mutate(
    season = factor(season, levels = season_levels),
    period = factor(period, levels = period_levels)) %>% 
  ungroup()
```

### COG Timeseries

```{r}
#| label: center of gravity timeseries
#| eval: true

# Markers for lat/lon areas
cog_markers <- tibble(
  "label" = c("Chatham, MA", "NY/NJ Bight", 
              "Cape May, NJ", "Jordan Basin, ME"),
  "lon"   = c(-69.927,  -73.375, -74.626, -67.846
),
  "lat"   = c(41.678, 40.241, 38.900, 43.633))



# Center of latitude
ggplot() +
  geom_hline(
    data = cog_markers, 
    aes(yintercept = lat), alpha = 0.4) +
  geom_line(
    data = single_species_cog, 
    aes(x = year, y = COGy, color = season), lwd = 1) +
  scale_color_manual(
    name = "season", 
    values = c("#66c2a5", "#fc8d62", "#8da0cb")) +
  geom_label(
    data = cog_markers, 
    aes(x = I(0.1), y = lat, label = label), 
    size = 2) +
  scale_x_continuous(limits = c(1965, 2100)) +
  labs(x = "Year", y = "Center of Latitude") +
  facet_nested(
    model_type~species*scenario,
    labeller = labeller(model_type = label_wrap_gen(width = 8)), 
    scales = "fixed", nest_line = T)  +
  theme(
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank()) +
  labs(title = "Center of Latitude")


```



### COG Lon

```{r}

# Center of latitude
ggplot() +
  geom_vline(
    data = cog_markers, 
    aes(xintercept = lon), alpha = 0.4) +
  geom_path(
    data = arrange(single_species_cog, year),
    aes(x = COGx, y = year, color = season), lwd = 1) +
  scale_color_manual(
    name = "season", 
    values = c("#66c2a5", "#fc8d62", "#8da0cb")) +
  geom_label(
    data = cog_markers, 
    aes(y = I(0.1), x = lon, label = label), 
    size = 2) +
  scale_y_continuous(limits = c(1965, 2100)) +
  scale_x_continuous(limits = c(-72, -60)) +
  facet_nested(
    model_type~species*scenario,
    labeller = labeller(model_type = label_wrap_gen(width = 8)), 
    scales = "fixed", nest_line = T)  +
  theme(
    panel.grid.major.y = element_blank(),
    panel.grid.minor.y = element_blank()) +
  labs(
    title = "Center of Longitude",
    x = "Longitude", 
    y = "Year")

```


### COG Maps

```{r}
#| eval: true

# Map the locations
single_species_cog_sf <- single_species_cog %>% 
  filter(period != "drop") %>% 
  st_as_sf(coords = c("COGx", "COGy"), crs = 4326)


ggplot() +
  geom_sf(data = land_sf, color = "dark gray", lwd = 0.2, na.rm = TRUE) +
  geom_sf(data = hague_sf, color = "black", linetype = 3) + 
  geom_sf(
    data = single_species_cog_sf, 
    aes(color = season), alpha = 1, size = 1.2) + 
  scale_color_manual(
    name = "season", values = c("#66c2a5", "#fc8d62", "#8da0cb")) +
  coord_sf(
    xlim = range(single_species_cog$COGx) + c(-2.5, 2.5), 
    ylim = range(single_species_cog$COGy) + c(-1.5, 1.5), 
    expand = T, crs = 4326) +
    scale_fill_viridis_c(name = "Center of Gravity") +
    facet_nested(
      model_type~species*scenario*period, 
      labeller = labeller(model_type = label_wrap_gen(width = 8))) +
    theme_map() +
    theme(panel.grid.major  = element_blank()) +
    guides(color = guide_legend(override.aes = list(shape = 15, size = 5)))

```


```{r}
#| label: COG with ggside
#| eval: true

# Does not work with sf, Just use year-round
library(ggside)


# Estimate center of gravity
single_species_cog_annual <- projections |>
    mutate(biomass_total = mean_response * area) %>% 
    filter(period != "drop") %>% 
    group_by(model_type, period, scenario, species, year) |>
    nest() %>% 
    mutate(
      ID = row_number(),
      COG = map(data, ~ response_scale_COGrav(.x, biomass_col = "biomass_total"))) |>
    unnest_wider(COG) 


# Plot them with side histograms?
ggplot(single_species_cog_annual, aes(COGx, COGy, color = period)) +
  geom_point(aes(color = period), alpha = 0.9) +
  geom_xsidehistogram(
    aes(y = after_stat(density), fill = period), 
    position = "dodge") +
  geom_ysidehistogram(
    aes(x = after_stat(density), fill = period), 
    position = "dodge") +
  scale_color_carto_d() +
  scale_fill_carto_d() +
  facet_grid(
    model_type~species*scenario,
    labeller = labeller(
      model_type = label_wrap_gen(width = 8))) +
  #theme_map() +
  theme(panel.grid.major = element_blank()) +
  guides(color = guide_legend(
    override.aes = list(shape = 15, size = 5))) +
  theme(ggside.panel.scale = .3) +
  labs(
    title = "Center of Biomass Shifts",
    subtitle = "Lat + Lon Components Displayed as Decadal Distributions",
    y = "Latitude",
    x = "Longitude")


```


# Modeling Choice Diagnostics

Get outputs from Andrew for cod, halibut, and lobster and make tables or visuals to help us:


## Forward Projection of Error:

 1. See the effects of different forward-projection methods within spatio-temporal model (e.g., AR1 vs RW vs IID year-season selection)
i.e., how does the choice of method affect resulting trends in biomass, COG, variance, etc.?


## Model Performance Statistics

 2. Compare model performance statistics (AIC, explanatory power, RMSE, etc.) for different model structures (i.e., null/envt-only, spatial, spatio-temporal)--Im thinking this could just be a table
 


If you have other ideas of things we should look at / ways to look at this to help us get to final model selection, please let us know.


# Residual Plots

Do we want to use the residuals??

# Deprecated Section

Everything below was dug into, but likely won't be needed for the primary diagnostics

# Spatially Varying Season Effects (SeasonSVC)


In some models, the seasonal effect is fit as a spatially explicit surface.

## SeasonSVC


```{r}
#| label: process seasonal svc marginals

# # Just need a single year, grab all locations and their combinations with the seasons
# # Set scaled depth and bottom temperature to zero
# season_effect_df <- projections %>% 
#   filter(
#     year == 2010,
#     species == "Cod") %>% 
#   distinct(
#     species, year, longitude, latitude, survey, season, 
#     `factor(season)spring`, `factor(season)summer`, `factor(season)fall`) %>% 
#   mutate(
#     "Depth_scaled" = 0,
#     "BT_seasonal_scaled" = 0
#   )
# 
# # I can grab the year_season_int from the fitted period
# season_year_int_schematic <- sdm_mods[[str_c(test_species,"_null")]]$data %>% 
#   filter(year == 2010) %>% 
#   distinct(year, season, year_season_int)
# 
# # Join that back in
# season_effect_df <- left_join(season_effect_df, season_year_int_schematic)
# 
# # Use predict
# season_marginal_effects <- predict(
#   sdm_mods[[str_c(test_species,"_null")]],
#   season_effect_df,
#   se_fit = F)


# est = biomass on log scale
# zeta_s_`factor(season)spring` = spatially varying coefficient?
```


### Seasonal Marginal Effects

```{r}
#| label: season svc marginal map

# # Map check
# season_marginal_effects %>% 
#   left_join(sdm_hex_grid) %>%
#   st_as_sf() %>%
#   ggplot() +
#   geom_sf(aes(fill = est)) +
#   scale_fill_distiller(
#     palette = "RdBu", 
#     limits = c(-5, 5), 
#     oob = oob_squish) +
#   theme_map() +
#   facet_grid(species~season) +
#   labs(
#     title = "Season Marginal Effects Map",
#     subtitle = "Estimated Biomass (link scale)")
```

### Seasonal Zetas



```{r}
#| label: seasonal zeta

# # Reshape data for season zeta
# season_zetas <- season_marginal_effects %>% 
#   distinct(
#     species, longitude, latitude, 
#     `zeta_s_\`factor(season)spring\``, `zeta_s_\`factor(season)summer\``, 
#     `zeta_s_\`factor(season)fall\``) %>% 
#   setNames(c("species", "longitude", "latitude", "spring", "summer", "fall")) %>% 
#   pivot_longer(
#     cols = -c(species, longitude, latitude),
#     names_to = "season",
#     values_to = "zeta") %>% 
#   mutate(season = factor(season, levels = season_levels)) 
# 
# # Plot them without the main season effect
# season_zetas %>% 
#   left_join(sdm_hex_grid) %>%
#   st_as_sf() %>%
#   ggplot() +
#   geom_sf(aes(fill = zeta)) +
#   scale_fill_distiller(
#     palette = "RdBu", 
#     limits = c(-10, 10), 
#     oob = oob_squish) +
#   facet_wrap(~season) +
#   theme_map() +
#   facet_grid(species~season) +
#   labs(title = "Season Zeta, w/o Main Season Effect",
#        subtitle = "Coefficient Estimate for Spatially-Varying")
```


### Season Zetas + Main Effect


```{r}
#| label: season svc zeta + season main
# Next:

# # Two season effects:
# # Main effect: factor(season)spting
# # spatially varying season
# # Then we want to pull coefficients,
# # These values get added to the spatially varying before mapping
# season_main_effects <- tidy(sdm_mods$Cod_sp) %>% 
#   filter(str_detect(term, "summer|fall")) %>% 
#   mutate(season = str_remove(term, "factor(season)"))
#   
# # Plot them without the main season effect
# season_zetas %>% 
#   left_join(season_main_effects) %>% 
#   mutate(
#     estimate = if_else(is.na(estimate), 0, estimate),
#     full_seasonal = zeta + estimate,
#     season = factor(season, levels = season_levels)) %>% 
#   left_join(sdm_hex_grid) %>%
#   st_as_sf() %>%
#   ggplot() +
#   geom_sf(aes(fill = full_seasonal)) +
#   scale_fill_distiller(
#     palette = "RdBu", 
#     limits = c(-10, 10), 
#     oob = oob_squish) +
#   facet_wrap(~season) +
#   theme_map() +
#   facet_grid(species~season) +
#   labs(title = "Season Zeta + Main Season Effect")


```


## Model Type Impact on Seaonal Effects


```{r}
#| label: attempt to do different model predictions
#| eval: false



# I can grab the year_season_int from the fitted period
season_marginal_effects <- list(
  "SeasonSVC" = sdm_mods[[str_c(test_species,"_null")]], 
  "SeasonSVC + SP" = sdm_mods$Cod_sp#, 
  #"SeasonSVC + SP + SP_ST" = sdm_mods$Cod_sp_st
  )  %>% 
  # Run all three
  imap_dfr(function(sdm_mod_x, model_type_x){
    
    # Pull the lat, lon, season details to project along
    season_prediction_structure <- projections %>% 
      filter(
        year == 2010,
        species == "Cod",
        model_type == model_type_x) %>% 
      distinct(
        species, year, survey, season, longitude, latitude, 
        `factor(season)spring`, `factor(season)summer`, `factor(season)fall`) %>% 
      mutate(
        "Depth_scaled" = 0,
        "BT_seasonal_scaled" = 0
      )

    
    # Get the season_year_int structure
     season_year_int_schematic <- sdm_mod_x$data %>% 
      filter(year == 2010) %>% 
      distinct(year, season, year_season_int, year_season_fac)
    
    
    # Join that back in
    season_effect_df <- left_join(
      x = season_prediction_structure, 
      y = season_year_int_schematic)
    
    # Use predict
    season_marginal_effects <- predict(
      sdm_mod_x,
      season_effect_df,
      se_fit = FALSE)
    
    return(season_marginal_effects)
    
  },.id = "model_type")




# Map check
season_marginal_effects %>% 
  left_join(sdm_hex_grid) %>%
  st_as_sf() %>%
  ggplot() +
  geom_sf(aes(fill = est)) +
  scale_fill_distiller(
    palette = "RdBu", 
    limits = c(-5, 5), 
    oob = oob_squish) +
  theme_map() +
  facet_nested(model_type ~ species*season) +
  labs(
    title = "Season Marginal Effects Map",
    subtitle = "Estimated Biomass (link scale)")


```


